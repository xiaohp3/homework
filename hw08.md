View on GitHub
Homework Space
Homework Space for Introduction to Software Engineering
Dec to Hex Algorithm
1) Pseudocode

Procedure dec2hex(N)
    IF N = 0 THEN
        Print "0"
        END Procedure
    END IF

    IF N < 0 THEN
        SET N to -N
        Print "-"
    END IF

    SET i to 0
    WHILE N != 0
        SET Digit[i] to the remainder of N divided by 16
        INCREMENET i
        DIVIDE N by 16
    END WHILE

    
    FOR each Number in array Digit from back
        Print the corresponding hexadecimal digit of Number
    END LOOP
2) Implemented in C

```C
#include <stdio.h>

void change(int N) {
	if (N == 0) {
		printf("0\n\n");
		return;
	}
	
	if (N < 0) {
		N = -N;
		putchar('-');
	}
	
	int i = 0;
	int Digit[10];
	while (N != 0) {
		Digit[i] = N % 16;
		++i;
		N /= 16;
	}
	
	int Number;
	for (--i; i >= 0; --i) {
		Number = Digit[i];
		if (Number < 10) {
			putchar('0' + Number);
		}
		else {
			putchar('A' + Number - 10);
		}
	}
	printf("\n\n");
}

int main() {
	int N;
	while (1) {
		scanf("%d", &N);
		change(N);
	}
	return 0;
}
```
3) Result

result-0



Words Explanation and Comparison
1) Top-down design

Top-down is a strategy of information processing and knowledge ordering, used in a variety of fields including software, humanistic and scientific theories, and management and organization. In practice, it can be seen as a style of thinking, teaching, or leadership.

A top-down approach is essentially the breaking down of a system to gain insight into its compositional sub-systems in a reverse engineering fashion. In a top-down approach an overview of the system is formulated, specifying, but not detailing, any first-level subsystems. Each subsystem is then refined in yet greater detail, sometimes in many additional subsystem levels, until the entire specification is reduced to base elements. A top-down model is often specified with the assistance of “black boxes”, which makes it easier to manipulate. However, black boxes may fail to clarify elementary mechanisms or be detailed enough to realistically validate the model. Top down approach starts with the big picture. It breaks down from there into smaller segments.

自顶向下是一种处理信息和整理知识的策略，它被用在许多领域，包括软件、人文理论、科学理论、管理学等。在实践中，它可以被看做是一种思考、教导、领导的方式。

自顶向下方法本质上是把一个系统分解，以观察到组成它的子系统。在自顶向下方法中，对于一个系统的概观形成了，但是缺乏每个一级子系统的细节，每个子系统会被改善，使之具有更多细节，有时是另外的子系统，直到整个概念被化简为基本元素。自顶向下的模型经常借助 “黑盒” 来描述，这使得它更容易操作。然而，黑盒或许无法描述某些基本机制，也或许细节不够多使得模型实际上不成立。自顶向下方法着手大局，并把它分解为小部分。

2) Work breakdown structure

A work-breakdown structure (WBS) in project management and systems engineering, is a deliverable-oriented breakdown of a project into smaller components. A work breakdown structure is a key project deliverable that organizes the team’s work into manageable sections. The Project Management Body of Knowledge (PMBOK 5) defines the work-breakdown structure “A hierarchical decomposition of the total scope of work to be carried out by the project team to accomplish the project objectives and create the required deliverables.”

A work-breakdown structure element may be a product, data, service, or any combination thereof. A WBS also provides the necessary framework for detailed cost estimating and control along with providing guidance for schedule development and control.

项目管理和系统工程中的工作分解结构（WBS）是一种把一个项目分成若干小部分的、以可交付成果为导向的分解。工作分解结构把团队工作分解成可管理的部分。《项目管理知识体系指南》把工作分解结构定义为 “对一项工作的层次化分解，这项工作是一个团队完成的，这个团队将完成项目目标并开发出可交付成果”。

工作分解结构的元素可以为产品、数据、服务或者它们的组合。工作分解结构也为详细支出预估和管理提供了一个必要的框架，也为开发计划和管理提供了指南。

3) Comparison between WBS and top-down design

相同点：都是对一个大的概念进行分解，使之成为若干个小的部分，都是一个逐步求精的过程。

不同点：WBS 一般是针对团队项目而言的，最终会把大型项目分解成若干小的子任务，分配给个人；而自顶向下设计方法则更广，不止针对团队项目。从某种角度，WBS 是 top-down design 的一种应用。



Washing Machine
以我们宿舍的洗衣机为例

1) 大步骤

用户输入洗衣配置（模式、水量、过程）
浸洗（如果需要）
洗涤（如果需要）
漂洗（如果需要）
脱水（如果需要）
结束
2) 伪代码
```
Procedure set_config
	SET Mode, Volume, Step according to user's input(by pressing buttons)

Procedure soak
	water_in_switch(open)
	REPEAT
		Set CurrentVolume to get_water_volume()
	UNTIL CurrentVolume = VOLUME
	water_in_switch(close)
	SET StartTime to time_counter()
	REPEAT
		Set CurrentTime to time_counter()
	UNTIL CurrentTime > StartTime + SOAKING_TIME
	
Procedure wash(WashingTime)
	SET StartTime to time_counter()
	REPEAT
		SET Counter to 0
		REPEAT
			INCREMENT Counter
			SET CurrentTime to time_counter()
			motor_run(right)
			SET Temp1 to time_counter()
			REPEAT
				SET Temp2 to time_counter()
			UNTIL Temp2 > Temp1
			motor_run(stop)
			SET Temp1 to time_counter()
			REPEAT
				SET Temp2 to time_counter()
			UNTIL Temp2 > Temp1
			motor_run(left)
			SET Temp1 to time_counter()
			REPEAT
				SET Temp2 to time_counter()
			UNTIL Temp2 > Temp1
			motor_run(stop)
			SET Temp1 to time_counter()
			REPEAT
				SET Temp2 to time_counter()
			UNTIL Temp2 > Temp1
		UNTIL Counter = 10
		SET Temp1 to time_counter()
		REPEAT
			SET Temp2 to time_counter()
		UNTIL Temp2 > Temp1 + 2
	UNTIL CurrentTime > StartTime + WashingTime
	water_out_switch(open)
	REPEAT
		CurrentVolume = get_water_volume()
	UNTIL CurrentVolume = 0
	water_out_switch(close)

Procedure rinse
	SET Counter to 0
	REPEAT
		INCREMENT Counter
		water_in_switch(open)
		REPEAT
			Set CurrentVolume to get_water_volume()
		UNTIL CurrentVolume = VOLUME
		water_in_switch(close)

		wash(120)

	UNTIL Counter = 4

Procedure spin
	water_out_switch(open)
	REPEAT
		CurrentVolume = get_water_volume()
	UNTIL CurrentVolume = 0
	water_out_switch(close)
	
	motor_run(right)
	SET StartTime to time_counter()
	REPEAT
		SET CurrentTime to time_counter()
	UNTIL CurrentTime > StartTime + SPIN_TIME

Procedure end
	halt(success)

3) 快速洗衣

“正常洗衣” 与 “快速洗衣” 在用户目标方面的不同之处在于，后者更适合小型衣物，或者好洗的衣物，可以洗得更快一点；在程序方面得不同之处在于，每个步骤的执行次数或者时间不一样。存在改进空间，最好可以让用户的输入更加具体一点，比如可以让用户自由改变每个步骤的时间或者执行次数。

4) 共性功能模块

Procudure wait_for_seconds(sec)
	SET StartTime to time_counter()
	REPEAT
		SET CurrentTime to time_counter()
	UNTIL CurrentTime > StartTime + sec

Procedure add_water(vol, timeout)
	SET StartTime to time_counter()
	water_in_switch(open)
	REPEAT
		SET CurrentVolume to get_water_volume()
		SET CurrentTime to time_counter()
		IF CurrentTime > StartTime + timeout THEN
			halt(failure)
			END Procedure
		END IF
	UNTIL CurrentVolume = vol
	water_in_switch(close)

Procedure drain(timeout)
	SET StartTime to time_counter()
	water_out_switch(open)
	REPEAT
		SET CurrentVolume to get_water_volume()
		SET CurrentTime to time_counter()
		IF CurrentTime > StartTime + timeout THEN
			halt(failure)
			END Procedure
		END IF
	UNTIL CurrentVolume = 0
	water_out_switch(close)
